<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,
								initial-scale=1.0">
	<title>Sudoku Puzzle</title>
	<style>
        .codepen-button {
    display: block;
    cursor: pointer;
    color: white;
    margin: 0 auto;
    position: relative;
    text-decoration: none;
    font-weight: 600;
    border-radius: 6px;
    overflow: hidden;
    padding: 3px;
    isolation: isolate;
  }
  
  .codepen-button::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 400%;
    height: 100%;
    background: linear-gradient(115deg,#4fcf70,#fad648,#a767e5,#12bcfe,#44ce7b);
    background-size: 25% 100%;
    animation: an-at-keyframe-css-at-rule-that-translates-via-the-transform-property-the-background-by-negative-25-percent-of-its-width-so-that-it-gives-a-nice-border-animation_-We-use-the-translate-property-to-have-a-nice-transition-so-it_s-not-a-jerk-of-a-start-or-stop .75s linear infinite;
    animation-play-state: paused;
    translate: -5% 0%;
    transition: translate 0.25s ease-out;
  }
  
  .codepen-button:hover::before {
    animation-play-state: running;
    transition-duration: 0.75s;
    translate: 0% 0%;
  }
  
  @keyframes an-at-keyframe-css-at-rule-that-translates-via-the-transform-property-the-background-by-negative-25-percent-of-its-width-so-that-it-gives-a-nice-border-animation_-We-use-the-translate-property-to-have-a-nice-transition-so-it_s-not-a-jerk-of-a-start-or-stop {
    to {
      transform: translateX(-25%);
    }
  }
  
  .codepen-button span {
    position: relative;
    display: block;
    padding: 1rem 1.5rem;
    font-size: 1.1rem;
    background: #000;
    border-radius: 3px;
    height: 100%;
  }

button {
    margin: 0;
    padding: 0;
    background-color: none;
}
		body {
			font-family: Arial, sans-serif;
			background-color: #F5FCFF;
		}

		.container {
			display: flex;
			flex-direction: column;
			align-items: center;
			margin-top: 50px;
		}

		.row {
			display: flex;
		}

		.cell {
			width: 56px;
			height: 56px;
			border: 2px solid black;
			text-align: center;
			line-height: 30px;
			box-sizing: border-box;
		}

		.lightBackground {
			background-color: #A9A9A9;
		}

		.darkBackground {
			background-color: #EBF3E8;
		}

		.buttonContainer {
			margin-top: 20px;
			display: flex;
			/* Ensure buttons are always displayed */
			align-items: center;
			justify-content: center;
		}

		.buttonContainer button {
			margin-right: 10px;
			/* Add margin between buttons */
		}

		.result {
			margin-top: 20px;
			font-weight: 700;
            font-size: 18px;
		}

		.correct {
			color: green;
		}

		.incorrect {
			color: red;
		}
	</style>
</head>

<body>
    <h2 style="text-align: center;">SUdoku 2ª Versão</h2>
	<div class="container" id="container"></div>

	<div class="buttonContainer">
        <button style="width: 250px; height: 50px;"><a class="codepen-button" id="solveButton"><span>Resolver</span></a></button>
        <button style="width: 250px; height: 50px;"><a class="codepen-button" id="resetButton"><span>Resetar</span></a></button>
        <button style="width: 250px; height: 50px;"><a class="codepen-button" href="index.html"><span>Voltar</span></a></button>
	</div>
    

	<script>
		document.addEventListener("DOMContentLoaded", function () {
			const container = document.getElementById("container");

			// Function to generate a random Sudoku puzzle
			function generateRandomSudoku() {
				// Placeholder function for generating a random puzzle (9x9)
				const puzzle = [
					[5, 3, 0, 0, 7, 0, 0, 0, 0],
					[6, 0, 0, 1, 9, 5, 0, 0, 0],
					[0, 9, 8, 0, 0, 0, 0, 6, 0],
					[8, 0, 0, 0, 6, 0, 0, 0, 3],
					[4, 0, 0, 8, 0, 3, 0, 0, 1],
					[7, 0, 0, 0, 2, 0, 0, 0, 6],
					[0, 6, 0, 0, 0, 0, 2, 8, 0],
					[0, 0, 0, 4, 1, 9, 0, 0, 5],
					[0, 0, 0, 0, 8, 0, 0, 7, 9]
				];
				return puzzle;
			}

			// Function to solve the Sudoku puzzle
			function solveSudoku(board) {
				// Placeholder function for solving Sudoku puzzle
				const solvedPuzzle = JSON.parse(JSON.stringify(board));
				solveHelper(solvedPuzzle);
				return solvedPuzzle;
			}

			// Helper function for solving Sudoku recursively
			function solveHelper(board) {
				const emptyCell = findEmptyCell(board);
				if (!emptyCell) {
					return true; // Puzzle solved
				}

				const [row, col] = emptyCell;
				for (let num = 1; num <= 9; num++) {
					if (isValidMove(board, row, col, num)) {
						board[row][col] = num;
						if (solveHelper(board)) {
							return true;
						}
						board[row][col] = 0; // Backtrack
					}
				}
				return false; // No valid number found for this cell
			}

			// Function to find an empty cell in the Sudoku puzzle
			function findEmptyCell(board) {
				for (let row = 0; row < 9; row++) {
					for (let col = 0; col < 9; col++) {
						if (board[row][col] === 0) {
							return [row, col];
						}
					}
				}
				return null; // No empty cell found
			}

			// Function to check if a move is valid
			function isValidMove(board, row, col, num) {
				// Check row
				for (let i = 0; i < 9; i++) {
					if (board[row][i] === num) {
						return false;
					}
				}
				// Check column
				for (let i = 0; i < 9; i++) {
					if (board[i][col] === num) {
						return false;
					}
				}
				// Check 3x3 grid
				const startRow = Math.floor(row / 3) * 3;
				const startCol = Math.floor(col / 3) * 3;
				for (let i = startRow; i < startRow + 3; i++) {
					for (let j = startCol; j < startCol + 3; j++) {
						if (board[i][j] === num) {
							return false;
						}
					}
				}
				return true; // Move is valid
			}

			// Function to create the Sudoku puzzle grid
			function createSudokuGrid(puzzle) {
				container.innerHTML = '';
				puzzle.forEach((row, rowIndex) => {
					const rowElement = document.createElement('div');
					rowElement.classList.add('row');
					row.forEach((cell, columnIndex) => {
						const cellElement = document.createElement('input');
						cellElement.classList.add('cell');
						cellElement.classList
							.add((rowIndex + columnIndex) % 2 === 0 ?
								'lightBackground' : 'darkBackground');
						cellElement.type = 'text';
						cellElement.maxLength = 1;
						cellElement.value = cell !== 0 ? cell : '';
						rowElement.appendChild(cellElement);
					});
					container.appendChild(rowElement);
				});
			}

			// Initialize puzzle
			let initialPuzzle = generateRandomSudoku();
			let puzzle = JSON.parse(JSON.stringify(initialPuzzle));
			let solvedPuzzle = [];

			// Function to solve the puzzle
			function solvePuzzle() {
				solvedPuzzle = solveSudoku(puzzle);
				createSudokuGrid(solvedPuzzle);
			}

			// Function to reset the puzzle
			function resetPuzzle() {
				initialPuzzle = generateRandomSudoku();
				puzzle = JSON.parse(JSON.stringify(initialPuzzle));
				solvedPuzzle = [];
				createSudokuGrid(puzzle);
			}

			// Initial puzzle creation
			createSudokuGrid(puzzle);

			// Attach event listeners to buttons
			document.getElementById("solveButton")
				.addEventListener("click", solvePuzzle);
			document.getElementById("resetButton")
				.addEventListener("click", resetPuzzle);
		});
	</script>

</body>

</html>
